// Package cache implements a cache.
package cache

import (
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/coredns/coredns/middleware"
	"github.com/coredns/coredns/middleware/pkg/response"

	"github.com/hashicorp/golang-lru"
	"github.com/miekg/dns"
)

// Cache is middleware that looks up responses in a cache and caches replies.
// It has a success and a denial of existence cache.
type Cache struct {
	Next  middleware.Handler
	Zones []string

	ncache  *lru.Cache
	ncap    int
	nminttl time.Duration
	nttl    time.Duration

	pcache  *lru.Cache
	pcap    int
	pminttl time.Duration
	pttl    time.Duration

	// Prefetch.
	prefetch   int
	duration   time.Duration
	percentage int

	now func() time.Time
}

// Return key under which we store the item. The empty string is returned
// when we don't want to cache the message. Currently we do not cache Truncated, errors
// zone transfers or dynamic update messages.
func key(m *dns.Msg, t response.Type, do bool, keySuffix string) string {
	// We don't store truncated responses.
	if m.Truncated {
		return ""
	}
	// Nor errors or Meta or Update
	if t == response.OtherError || t == response.Meta || t == response.Update {
		return ""
	}

	qtype := m.Question[0].Qtype
	qname := strings.ToLower(m.Question[0].Name)
	return rawKey(qname, qtype, do, keySuffix)
}

func rawKey(qname string, qtype uint16, do bool, keySuffix string) string {
	if do {
		return "1" + qname + "." + strconv.Itoa(int(qtype)) + "/" + keySuffix
	}
	return "0" + qname + "." + strconv.Itoa(int(qtype)) + "/" + keySuffix
}

// ResponseWriter is a response writer that caches the reply message.
type ResponseWriter struct {
	dns.ResponseWriter
	*Cache

	// Tag will append to the cache key generated by dns.Msg
	Tag string

	prefetch bool // When true write nothing back to the client.
}

// WriteMsg implements the dns.ResponseWriter interface.
func (c *ResponseWriter) WriteMsg(res *dns.Msg) error {
	do := false
	mt, opt := response.Typify(res)
	if opt != nil {
		do = opt.Do()
	}

	// key returns empty string for anything we don't want to cache.
	key := key(res, mt, do, c.Tag)

	duration := c.pttl
	minttl := c.pminttl
	if mt == response.NameError || mt == response.NoData {
		duration = c.nttl
		minttl = c.nminttl
	}

	msgTTL := minMsgTTL(res, mt)
	if msgTTL < duration {
		duration = msgTTL
	}
	if duration < minttl {
		duration = minttl
	}

	if key != "" {
		c.set(res, key, mt, duration)

		cacheSize.WithLabelValues(Success).Set(float64(c.pcache.Len()))
		cacheSize.WithLabelValues(Denial).Set(float64(c.ncache.Len()))
	}

	if c.prefetch {
		return nil
	}

	setMsgTTL(res, uint32(duration.Seconds()))

	return c.ResponseWriter.WriteMsg(res)
}

func (c *ResponseWriter) set(m *dns.Msg, key string, mt response.Type, duration time.Duration) {
	if key == "" {
		log.Printf("[ERROR] Caching called with empty cache key")
		return
	}

	switch mt {
	case response.NoError, response.Delegation:
		i := newItem(m, duration)
		c.pcache.Add(key, i)

	case response.NameError, response.NoData:
		i := newItem(m, duration)
		c.ncache.Add(key, i)

	case response.OtherError:
		// don't cache these
	default:
		log.Printf("[WARNING] Caching called with unknown classification: %d", mt)
	}
}

// Write implements the dns.ResponseWriter interface.
func (c *ResponseWriter) Write(buf []byte) (int, error) {
	log.Printf("[WARNING] Caching called with Write: not caching reply")
	if c.prefetch {
		return 0, nil
	}
	n, err := c.ResponseWriter.Write(buf)
	return n, err
}

const (
	maxTTL  = 1 * time.Hour
	maxNTTL = 30 * time.Minute

	minTTL = 5 // seconds

	defaultCap = 10000 // default capacity of the cache.

	// Success is the class for caching positive caching.
	Success = "success"
	// Denial is the class defined for negative caching.
	Denial = "denial"
)
